/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, { useEffect, useMemo, useRef, useState } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import { useFrame, useGraph, useThree } from '@react-three/fiber'
import { CoreState, useGlobalStore } from '../state/globalState'
import { detectCollision } from '../utils/utils'
import { GLTFActions } from '../core/types/types'
import AudioManager from '../helpers/AudioManagerWeb'

export function Knight(props: any) {
  const group = props.objectRef || useRef<THREE.Group>()
  const [_, forceUpdate] = useState()
  const { materials, scene, animations } = props
  const { actions, mixer } = useAnimations<GLTFActions>(animations, group)
  // global store
  const setSlashFrameTime = useGlobalStore((state: CoreState) => state.setSlashFrameTime)
  const currentAction = useGlobalStore((state: CoreState) => state.currentAction)
  //const enemyPool = useGlobalStore((state: CoreState) => state.enemyPool)
  const setGameOver = useGlobalStore((state: CoreState) => state.setGameOver)
  const increaseCurrentScore = useGlobalStore((state: CoreState) => state.increaseCurrentScore)
  const mode = useGlobalStore((state: CoreState) => state.mode)
  const [finalNodes, setFinalNodes] = useState<any | null>(null)
  // end of global store
  // Skinned meshes cannot be re-used in threejs without cloning them
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene])

  // useGraph creates two flat object collections for nodes and materials
  const { nodes } = useGraph(clone)

  const currentAnimRef = useRef<any | null>(null)
  const [blockedSpell, setBlockedSpell] = useState<boolean>(false)
  const { viewport, size } = useThree()
  // FUNCTIONS //

  const updatePosition = () => {
    if (nodes && group.current) {
      const verticalPosition = -viewport.height / 2 + (110 / size.height) * viewport.height

      group.current.position.set(0, verticalPosition, 0)
    }
  }

  useEffect(() => {
    updatePosition()
  }, [viewport, size, nodes])

  useEffect(() => {
    //console.log('items: ', nodes.root)
    nodes.root?.traverse((descendent: any) => {
      if (descendent.name === '1H_Sword_Offhand') {
        // console.log('removing ', descendent.name)
        //nodes.root.remove(descendent)
        descendent.visible = false
        forceUpdate({})
      }
      // console.log(descendent)
    })
  }, [nodes])

  useEffect(() => {
    if (nodes && actions) {
      mixer.stopAllAction()
      if (currentAction === 'KNIGHT') {
        const animationKey = '1H_Melee_Attack_Slice_Horizontal'
        if (actions[animationKey]) {
          actions[animationKey].timeScale = 1
          actions[animationKey].reset()
          actions[animationKey].loop = THREE.LoopRepeat
          actions[animationKey].clampWhenFinished = true
          actions[animationKey].play()
          currentAnimRef.current = actions[animationKey]
        }
        // move forward a bit
        group.current.position.y += 1.5
      } else if (currentAction === 'MAGE') {
        const animationKey = 'Block'
        if (actions[animationKey]) {
          actions[animationKey].timeScale = 1
          actions[animationKey].reset()
          actions[animationKey].loop = THREE.LoopOnce
          actions[animationKey].clampWhenFinished = true
          actions[animationKey].syncWith(actions['Blocking']).play()
          currentAnimRef.current = actions[animationKey]
        }
        //setPlaySlash(false)
        group.current.position.y -= 1.5
      } else {
        const animationKey = 'Blocking'
        if (actions[animationKey]) {
          actions[animationKey].timeScale = 1
          actions[animationKey].reset()
          actions[animationKey].loop = THREE.LoopRepeat
          actions[animationKey].clampWhenFinished = true
          actions[animationKey].play()
          currentAnimRef.current = actions[animationKey]
        }
        //setPlaySlash(false)
      }
    }

    //currentAnim.current = '1H_Melee_Attack_Slice_Diagonal'
  }, [currentAction, nodes])

  useEffect(() => {
    if (blockedSpell) {
      const animationKey = 'Block_Attack'
      actions[animationKey].timeScale = 1
      actions[animationKey].reset()
      actions[animationKey].loop = THREE.LoopOnce
      actions[animationKey].clampWhenFinished = true
      actions[animationKey].syncWith(actions['Blocking']).play()
      currentAnimRef.current = actions[animationKey]
      setBlockedSpell(false)
    }
  }, [blockedSpell])

  useFrame(() => {
    let isColliding = false
    const enemyPool = useGlobalStore.getState().enemyPool
    for (let i = 0; i < enemyPool.length; i++) {
      let item = enemyPool[i]

      if (item.ref.current?.isActive === true) {
        let result = detectCollision(item.ref.current.getEnemyRef(), group)

        if (mode === 'NORMAL') {
          if (result === true && currentAction === 'KNIGHT' && item.ref.current?.getType() === 'skull') {
            isColliding = true
            item.ref.current?.destroy()
            increaseCurrentScore()
            break
          } else if (
            result === true &&
            (currentAction === 'MAGE' || currentAction === null) &&
            item.ref.current.getEnemyRef().position.y < group.current.position.y - 1.0
          ) {
            setGameOver(true)
            break
          }
        } else {
          if (result === true && currentAction === 'KNIGHT' && item.ref.current?.getType() === 'skull') {
            isColliding = true
            item.ref.current?.destroy()
            increaseCurrentScore()
            break
          } else if (result === true && currentAction === 'MAGE' && item.ref.current?.getType() === 'fireball') {
            isColliding = true
            item.ref.current?.destroy()
            increaseCurrentScore()
            break
          } else if (result === true) {
            // assume the right combination wasn't met
            console.log('game over!')
            setGameOver(true)
            break
          }
        }
      }
    }
    // show only on collision
    if (isColliding) {
      // KNIGHT MEANS SLASH, MAGE means BLOCK (don't ask)
      if (currentAnimRef.current && currentAction === 'KNIGHT') {
        //console.log(currentAnimRef.current.time)
        AudioManager.getInstance().playTrack('slash')
        if (currentAnimRef.current.time < 1.0) {
          setSlashFrameTime(currentAnimRef.current.time)
        }
      } else {
        setSlashFrameTime(-1)
      }
    }
  })

  return (
    <>
      {nodes && nodes.root && (
        <group ref={group} {...props} dispose={null}>
          <group name="Scene">
            <group name="Rig">
              <primitive object={nodes.root} dispose={null} />
              <skinnedMesh
                name="Knight_ArmLeft"
                geometry={nodes.Knight_ArmLeft.geometry}
                material={materials.knight_texture}
                skeleton={nodes.Knight_ArmLeft.skeleton}
              />
              <skinnedMesh
                name="Knight_ArmRight"
                geometry={nodes.Knight_ArmRight.geometry}
                material={materials.knight_texture}
                skeleton={nodes.Knight_ArmRight.skeleton}
              />
              <skinnedMesh
                name="Knight_Body"
                geometry={nodes.Knight_Body.geometry}
                material={materials.knight_texture}
                skeleton={nodes.Knight_Body.skeleton}
              />
              <skinnedMesh
                name="Knight_Head"
                geometry={nodes.Knight_Head.geometry}
                material={materials.knight_texture}
                skeleton={nodes.Knight_Head.skeleton}
              />
              <skinnedMesh
                name="Knight_LegLeft"
                geometry={nodes.Knight_LegLeft.geometry}
                material={materials.knight_texture}
                skeleton={nodes.Knight_LegLeft.skeleton}
              />
              <skinnedMesh
                name="Knight_LegRight"
                geometry={nodes.Knight_LegRight.geometry}
                material={materials.knight_texture}
                skeleton={nodes.Knight_LegRight.skeleton}
              />
            </group>
          </group>
        </group>
      )}
    </>
  )
}

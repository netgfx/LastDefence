/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, { useEffect, useMemo, useRef, useState } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import { extend, useFrame, useGraph, useThree } from '@react-three/fiber'
import { CoreState, useGlobalStore } from '../state/globalState'
import { detectCollision } from '../utils/utils'
import { GLTFActions } from '../core/types/types'
import AudioManager from '../helpers/AudioManagerWeb'

export function UnitsSide(props: any) {
  const group = props.objectRef || useRef<THREE.Group>()
  const group2 = props.objectRef2 || useRef<THREE.Group>()
  const [_, forceUpdate] = useState()
  const { nodes, materials, animations, scene } = props
  const { actions, mixer } = useAnimations<GLTFActions>(animations, group)
  const { actions: actions2, mixer: mixer2 } = useAnimations<GLTFActions>(animations, group2)
  // global store
  const setSlashSidesFrameTime = useGlobalStore((state: CoreState) => state.setSlashSidesFrameTime)
  const currentAction = useGlobalStore((state: CoreState) => state.currentAction)
  const setSide1ModelRef = useGlobalStore((state: CoreState) => state.setSideModel1Ref)
  const setGameOver = useGlobalStore((state: CoreState) => state.setGameOver)
  const increaseCurrentScore = useGlobalStore((state: CoreState) => state.increaseCurrentScore)
  // end of global store

  // Skinned meshes cannot be re-used in threejs without cloning them
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene])

  // useGraph creates two flat object collections for nodes and materials
  const { nodes: clonedNodes } = useGraph(clone)

  const { viewport, size } = useThree()

  const currentAnimRef = useRef<any | null>(null)
  const [blockedSpell, setBlockedSpell] = useState<boolean>(false)

  //

  const updatePosition = () => {
    if (nodes && group.current && group2.current) {
      const verticalPosition = -viewport.height / 2 + (110 / size.height) * viewport.height

      group.current.position.set(-10, verticalPosition, 0)
      group2.current.position.set(10, verticalPosition, 0)
    }
  }

  useEffect(() => {
    updatePosition()
    setSide1ModelRef(group.current)
  }, [viewport, size, nodes])

  useEffect(() => {
    //console.log('items: ', nodes.root)
    nodes?.root?.traverse((descendent: any) => {
      if (descendent.name === '1H_Sword_Offhand') {
        // console.log('removing ', descendent.name)
        //nodes.root.remove(descendent)
        descendent.visible = false
      }
      // console.log(descendent)
    })

    clonedNodes?.root?.traverse((descendent: any) => {
      if (descendent.name === '1H_Sword_Offhand') {
        // console.log('removing ', descendent.name)
        //nodes.root.remove(descendent)
        descendent.visible = false
      }
      // console.log(descendent)
    })

    forceUpdate({})
  }, [nodes, clonedNodes])

  useEffect(() => {
    if (nodes && clonedNodes && actions && actions2) {
      mixer.stopAllAction()
      mixer2.stopAllAction()
      if (currentAction === 'MAGE') {
        const animationKey = '1H_Melee_Attack_Slice_Horizontal'
        if (actions[animationKey]) {
          actions[animationKey].timeScale = 1
          actions[animationKey].reset()
          actions[animationKey].loop = THREE.LoopRepeat
          actions[animationKey].clampWhenFinished = true
          actions[animationKey].play()
          currentAnimRef.current = actions[animationKey]
        }
        //
        if (actions2[animationKey]) {
          actions2[animationKey].timeScale = 1
          actions2[animationKey].reset()
          actions2[animationKey].loop = THREE.LoopRepeat
          actions2[animationKey].clampWhenFinished = true
          actions2[animationKey].play()
        }
        //
        // move forward a bit
        group.current.position.y += 1.5
        group2.current.position.y += 1.5
      } else if (currentAction === 'KNIGHT') {
        const animationKey = 'Block'
        if (actions[animationKey]) {
          actions[animationKey].timeScale = 1
          actions[animationKey].reset()
          actions[animationKey].loop = THREE.LoopOnce
          actions[animationKey].clampWhenFinished = true
          actions[animationKey].syncWith(actions['Blocking']).play()
          currentAnimRef.current = actions[animationKey]
        }
        //
        if (actions2[animationKey]) {
          actions2[animationKey].timeScale = 1
          actions2[animationKey].reset()
          actions2[animationKey].loop = THREE.LoopOnce
          actions2[animationKey].clampWhenFinished = true
          actions2[animationKey].syncWith(actions['Blocking']).play()
        }
        //setPlaySlash(false)
        group.current.position.y -= 1.5
        group2.current.position.y -= 1.5
      } else {
        const animationKey = 'Blocking'
        if (actions[animationKey]) {
          actions[animationKey].timeScale = 1
          actions[animationKey].reset()
          actions[animationKey].loop = THREE.LoopRepeat
          actions[animationKey].clampWhenFinished = true
          actions[animationKey].play()
        }
        //

        if (actions2[animationKey]) {
          actions2[animationKey].timeScale = 1
          actions2[animationKey].reset()
          actions2[animationKey].loop = THREE.LoopRepeat
          actions2[animationKey].clampWhenFinished = true
          actions2[animationKey].play()
          currentAnimRef.current = actions[animationKey]
        }
        //setPlaySlash(false)
      }
    }
    //currentAnim.current = '1H_Melee_Attack_Slice_Diagonal'
  }, [currentAction, nodes, clonedNodes, actions, actions2])

  useEffect(() => {
    if (blockedSpell) {
      const animationKey = 'Block_Attack'
      actions[animationKey].timeScale = 1
      actions[animationKey].reset()
      actions[animationKey].loop = THREE.LoopOnce
      actions[animationKey].clampWhenFinished = true
      actions[animationKey].syncWith(actions['Blocking']).play()
      //
      actions2[animationKey].timeScale = 1
      actions2[animationKey].reset()
      actions2[animationKey].loop = THREE.LoopOnce
      actions2[animationKey].clampWhenFinished = true
      actions2[animationKey].syncWith(actions['Blocking']).play()
      currentAnimRef.current = actions[animationKey]
      setBlockedSpell(false)
    }
  }, [blockedSpell])

  useFrame(() => {
    let isColliding: boolean = false
    const enemyPool = useGlobalStore.getState().enemyPool
    // collision check
    for (let i = 0; i < enemyPool.length; i++) {
      let item = enemyPool[i]
      //console.log(item)
      if (item.ref.current?.isActive === true) {
        let result = detectCollision(item.ref.current.getEnemyRef(), group)
        let result2 = detectCollision(item.ref.current.getEnemyRef(), group2)

        if ((result === true || result2 === true) && currentAction === 'MAGE' && item.ref.current.getType() === 'skull') {
          isColliding = true
          item.ref.current?.destroy()
          increaseCurrentScore()
          break
        } else if (
          (result === true || result2 === true) &&
          (currentAction === 'KNIGHT' || currentAction === null) &&
          (item.ref.current.getEnemyRef().position.y < group.current.position.y - 1.0 ||
            item.ref.current.getEnemyRef().position.y < group2.current.position.y - 1.0)
        ) {
          setGameOver(true)
          break
        }
      }
    }

    // show only on collision
    if (isColliding) {
      // KNIGHT MEANS SLASH, MAGE means BLOCK (don't ask)
      if (currentAnimRef.current && currentAction === 'MAGE') {
        AudioManager.getInstance().playTrack('slash')
        //console.log(currentAnimRef.current.time)
        //if (currentAnimRef.current.time < 1.0) {
        setSlashSidesFrameTime(currentAnimRef.current.time)
        //}
      } else {
        setSlashSidesFrameTime(-1)
      }
    }
  })

  // useFrame(() => {
  //   if (currentAnimRef.current && currentAction === 'MAGE') {
  //     //console.log(currentAnimRef.current.time)
  //     if (currentAnimRef.current.time < 1.0) {
  //       setSlashSidesFrameTime(currentAnimRef.current.time)
  //     }
  //   } else {
  //     setSlashSidesFrameTime(-1)
  //   }
  // })

  return (
    <>
      {nodes && clonedNodes && (
        <>
          <group ref={group} {...props} dispose={null}>
            <group name="SceneSide1">
              <group name="Rig1">
                <skinnedMesh
                  name="Knight_ArmLeft"
                  geometry={nodes.Knight_ArmLeft.geometry}
                  material={materials.knight_texture}
                  skeleton={nodes.Knight_ArmLeft.skeleton}
                />
                <skinnedMesh
                  name="Knight_ArmRight"
                  geometry={nodes.Knight_ArmRight.geometry}
                  material={materials.knight_texture}
                  skeleton={nodes.Knight_ArmRight.skeleton}
                />
                <skinnedMesh
                  name="Knight_Body"
                  geometry={nodes.Knight_Body.geometry}
                  material={materials.knight_texture}
                  skeleton={nodes.Knight_Body.skeleton}
                />
                <skinnedMesh
                  name="Knight_Head"
                  geometry={nodes.Knight_Head.geometry}
                  material={materials.knight_texture}
                  skeleton={nodes.Knight_Head.skeleton}
                />
                <skinnedMesh
                  name="Knight_LegLeft"
                  geometry={nodes.Knight_LegLeft.geometry}
                  material={materials.knight_texture}
                  skeleton={nodes.Knight_LegLeft.skeleton}
                />
                <skinnedMesh
                  name="Knight_LegRight"
                  geometry={nodes.Knight_LegRight.geometry}
                  material={materials.knight_texture}
                  skeleton={nodes.Knight_LegRight.skeleton}
                />
                <primitive object={nodes.root} />
              </group>
            </group>
          </group>

          <group ref={group2} {...props} dispose={null}>
            <group name="SceneSide2">
              <group name="Rig2">
                <skinnedMesh
                  name="Knight_ArmLeft"
                  geometry={clonedNodes.Knight_ArmLeft.geometry}
                  material={materials.knight_texture}
                  skeleton={clonedNodes.Knight_ArmLeft.skeleton}
                />
                <skinnedMesh
                  name="Knight_ArmRight"
                  geometry={clonedNodes.Knight_ArmRight.geometry}
                  material={materials.knight_texture}
                  skeleton={clonedNodes.Knight_ArmRight.skeleton}
                />
                <skinnedMesh
                  name="Knight_Body"
                  geometry={clonedNodes.Knight_Body.geometry}
                  material={materials.knight_texture}
                  skeleton={clonedNodes.Knight_Body.skeleton}
                />
                <skinnedMesh
                  name="Knight_Head"
                  geometry={clonedNodes.Knight_Head.geometry}
                  material={materials.knight_texture}
                  skeleton={clonedNodes.Knight_Head.skeleton}
                />
                <skinnedMesh
                  name="Knight_LegLeft"
                  geometry={clonedNodes.Knight_LegLeft.geometry}
                  material={materials.knight_texture}
                  skeleton={clonedNodes.Knight_LegLeft.skeleton}
                />
                <skinnedMesh
                  name="Knight_LegRight"
                  geometry={clonedNodes.Knight_LegRight.geometry}
                  material={materials.knight_texture}
                  skeleton={clonedNodes.Knight_LegRight.skeleton}
                />
                <primitive object={clonedNodes.root} dispose={null} />
              </group>
            </group>
          </group>
        </>
      )}
    </>
  )
}
